{# JavaScript for the application #}
{# Updated: Tab switching fix applied #}
<script>
    let problems = [];
    let currentProb = null;

    async function init() {
        // Load theme
        const savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-theme');
        }

        const res = await fetch('/api/problems');
        const data = await res.json();
        document.title = data.app_title;
        document.getElementById('page-title').textContent = data.app_title;
        document.getElementById('app-description').textContent = data.app_description;
        let metaDesc = document.querySelector('meta[name="description"]');
        if (!metaDesc) {
            metaDesc = document.createElement('meta');
            metaDesc.name = 'description';
            document.head.appendChild(metaDesc);
        }
        metaDesc.content = data.app_description;
        problems = data.problems;
        renderGrid();
        updateStats();
    }

    function toggleTheme() {
        document.body.classList.toggle('dark-theme');
        const isDark = document.body.classList.contains('dark-theme');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
        
        // Update editor theme if it exists
        if (editor && window.monaco) {
            monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs');
        }
    }

    function updateStats() {
        let passed = 0, failed = 0, totalScore = 0, maxScore = 0;
        problems.forEach(p => {
            if (p.has_run) {
                if (p.passed === p.total_tests && p.total_tests > 0) passed++; else failed++;
            }
            totalScore += p.score;
            maxScore += p.total_points;
        });
        document.getElementById('stat-passed').textContent = passed;
        document.getElementById('stat-failed').textContent = failed;
        document.getElementById('stat-score').textContent = `${totalScore} / ${maxScore}`;
    }

    function renderGrid() {
        const grid = document.getElementById('grid');
        grid.innerHTML = problems.map(p => {
            const statusClass = p.has_run ? (p.passed === p.total_tests && p.total_tests > 0 ? 'pass' : 'fail') : 'pending';
            const statusText = p.has_run ? (p.passed === p.total_tests && p.total_tests > 0 ? 'é€šé' : 'å¤±æ•—') : 'æœªåŸ·è¡Œ';
            const barClass = p.passed === p.total_tests && p.total_tests > 0 ? 'progress-bar' : 'progress-bar fail';
            const pct = p.total_tests > 0 ? (p.passed / p.total_tests) * 100 : 0;
            
            let statusHint = '';
            if (p.has_run && p.passed !== p.total_tests) {
                if (p.details.some(d => d.status === 'TLE')) statusHint = 'âš ï¸ é€¾æ™‚ (TLE)';
                else if (p.details.some(d => d.status === 'ERROR')) statusHint = 'âš ï¸ åŸ·è¡ŒéŒ¯èª¤ (Error)';
                else if (p.details.some(d => d.case === 'Compilation')) statusHint = 'ğŸ”§ ç·¨è­¯éŒ¯èª¤ (CE)';
                else if (p.details.some(d => d.case === 'Keyword Check')) statusHint = 'ğŸ” é—œéµå­—éŒ¯èª¤ (KW)';
            }

            return `
                <div class="tile" onclick="openModal('${p.name}')">
                    <div class="tile-header">
                        <div class="tile-title">${p.display_name || p.name}</div>
                        <div class="status-indicator ${statusClass}" id="status-${p.name}">${statusText}</div>
                    </div>
                    <div class="tile-body">
                        <div class="progress-track">
                            <div class="progress-bar ${barClass}" id="bar-${p.name}" style="width: ${pct}%"></div>
                        </div>
                        <div class="tile-meta">
                            <span id="score-${p.name}">å¾—åˆ†: ${p.score}/${p.total_points}</span>
                            <span id="tests-${p.name}">æ¸¬è©¦: ${p.passed}/${p.total_tests}</span>
                        </div>
                        ${statusHint ? `<div class="tile-status-hint" id="hint-${p.name}">${statusHint}</div>` : `<div class="tile-status-hint" id="hint-${p.name}"></div>`}
                    </div>
                </div>
            `;
        }).join('');
    }

    async function runProblem(e, probName) {
        if (e) e.stopPropagation();
        const status = document.getElementById(`status-${probName}`);
        if (status) status.className = 'status-indicator running';
        if (currentProb === probName && document.getElementById('modal-overlay').classList.contains('is-visible')) {
            document.getElementById('modal-body').innerHTML = `
                <div class="loading-container">
                    <div class="spinner"></div>
                    <p>åŸ·è¡Œæ¸¬è©¦ä¸­...</p>
                </div>`;
        }
        try {
            const res = await fetch(`/api/run/${probName}`, { method: 'POST' });
            const data = await res.json();
            const idx = problems.findIndex(p => p.name === probName);
            if (idx !== -1) {
                problems[idx].score = data.score;
                problems[idx].passed = data.passed_count;
                problems[idx].total_tests = data.total_count;
                problems[idx].has_run = true;
                problems[idx].details = data.details;
            }
            const pct = data.total_count > 0 ? (data.passed_count / data.total_count) * 100 : 0;
            const barEl = document.getElementById(`bar-${probName}`);
            barEl.style.width = `${pct}%`;
            barEl.className = data.passed_count === data.total_count && data.total_count > 0 ? 'progress-bar' : 'progress-bar fail';
            document.getElementById(`score-${probName}`).textContent = `å¾—åˆ†: ${data.score}/${data.total_points}`;
            document.getElementById(`tests-${probName}`).textContent = `æ¸¬è©¦: ${data.passed_count}/${data.total_count}`;
            const newStatus = (data.fail_count === 0 && data.total_count > 0) ? 'pass' : 'fail';
            document.getElementById(`status-${probName}`).className = `status-indicator ${newStatus}`;
            updateStats();
            if (currentProb === probName && document.getElementById('modal-overlay').classList.contains('is-visible')) {
                openModal(probName);
            }
        } catch (err) {
            console.error(err);
            if (status) status.className = 'status-indicator fail';
        }
    }

    async function runAll() {
        for (const p of problems) {
            await runProblem(null, p.name);
        }
    }

    async function openModal(probName) {
        currentProb = probName;
        const p = problems.find(x => x.name === probName);
        const displayName = p ? (p.display_name || p.name) : probName;
        document.getElementById('modal-title').textContent = displayName;
        document.getElementById('modal-overlay').classList.add('is-visible');
        
        // Reset to info tab
        switchTab('info');
        
        // Reset save button
        document.getElementById('btn-save').disabled = true;
        document.getElementById('btn-save').classList.add('btn-secondary');
        document.getElementById('btn-save').classList.remove('btn');
        
        // Reset results
        document.getElementById('results-container').innerHTML = '<div style="text-align:center; color: var(--cds-text-secondary);">å°šæœªåŸ·è¡Œæ¸¬è©¦</div>';
        
        // Only show loading if empty (first open), otherwise keep old content while refreshing? 
        // Actually for simplicity, let's show loading for now or just keep it simple.
        // If we are rerunning, we might want to keep the description visible. 
        // But openModal is called by tile click too.
        document.getElementById('modal-body').innerHTML = `
            <div class="loading-container">
                <div class="spinner"></div>
                <p>è¼‰å…¥ä¸­...</p>
            </div>`;
        
        try {
            const infoRes = await fetch(`/api/problem/${probName}/info`);
            const info = await infoRes.json();
            
            // Calculate status
            let statusHtml = '';
            if (p && p.has_run) {
                const isPass = p.passed === p.total_tests && p.total_tests > 0;
                const statusText = isPass ? 'é€šé (PASS)' : 'å¤±æ•— (FAIL)';
                const statusColor = isPass ? 'var(--cds-success)' : 'var(--cds-danger)';
                statusHtml = `
                    <div class="info-card" style="border-left: 4px solid ${statusColor}">
                        <div class="info-card-label">ç‹€æ…‹ (Status)</div>
                        <div class="info-card-value" style="color: ${statusColor}; font-size: 1.25rem;">${statusText}</div>
                    </div>
                `;
            } else {
                statusHtml = `
                    <div class="info-card">
                        <div class="info-card-label">ç‹€æ…‹ (Status)</div>
                        <div class="info-card-value" style="font-size: 1.25rem; color: var(--cds-text-secondary);">æœªåŸ·è¡Œ</div>
                    </div>
                `;
            }

            let html = '<div class="problem-info-section">';
            html += '<div class="info-grid">';
            html += `<div class="info-card"><div class="info-card-label">é…åˆ† (Points)</div><div class="info-card-value">${info.points}</div></div>`;
            html += `<div class="info-card"><div class="info-card-label">é™åˆ¶æ™‚é–“ (Timeout)</div><div class="info-card-value">${info.timeout || 1}s</div></div>`;
            html += statusHtml;
            html += '</div>';
            
            if ((info.forbidden && info.forbidden.length > 0) || (info.required && info.required.length > 0)) {
                html += '<div class="keywords-section">';
                if (info.forbidden && info.forbidden.length > 0) {
                    html += '<div class="keywords-group"><span class="keywords-label">ç¦æ­¢ä½¿ç”¨çš„é—œéµå­— (Forbidden)</span><div class="keyword-tags">';
                    info.forbidden.forEach(kw => { html += `<span class="keyword-tag forbidden">${kw}</span>`; });
                    html += '</div></div>';
                }
                if (info.required && info.required.length > 0) {
                    html += '<div class="keywords-group"><span class="keywords-label">å¿…é ˆä½¿ç”¨çš„é—œéµå­— (Required)</span><div class="keyword-tags">';
                    info.required.forEach(kw => { html += `<span class="keyword-tag required">${kw}</span>`; });
                    html += '</div></div>';
                }
                html += '</div>';
            }
            html += '</div>';
            
            if (info.description_md) {
                html += '<div class="problem-description">' + renderMarkdown(info.description_md) + '</div>';
            }
            
            document.getElementById('modal-body').innerHTML = html;
        } catch (err) {
            console.error(err);
            document.getElementById('modal-body').innerHTML = '<div style="text-align:center; padding: 32px;"><p>ç„¡æ³•è¼‰å…¥é¡Œç›®è³‡è¨Šã€‚</p></div>';
        }
    }

    function renderMarkdown(md) {
        let html = md;
        html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
        html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
        html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        html = html.split('\n\n').map(p => {
            if (p.startsWith('<h') || p.startsWith('<pre') || p.trim() === '') return p;
            return '<p>' + p.replace(/\n/g, '<br>') + '</p>';
        }).join('\n');
        return html;
    }

    function renderTestResults(details) {
        if (!details || details.length === 0) return '<p style="padding:16px">ç„¡æ¸¬è©¦è³‡æ–™ã€‚</p>';
        return details.map((d, i) => {
            const statusClass = d.status.toLowerCase();
            let content = '';
            if (d.status === 'PASS') {
                content = `<div class="diff-block"><div class="diff-col"><h5>è¼¸å…¥ (Input)</h5><div class="diff-box">${d.input}</div></div><div class="diff-col"><h5>è¼¸å‡º (Output)</h5><div class="diff-box">${d.output}</div></div></div>`;
            } else if (d.status === 'FAIL' && d.case === 'Keyword Check') {
                const forbiddenList = d.forbidden ? d.forbidden.join(', ') : 'ç„¡';
                const requiredList = d.required ? d.required.join(', ') : 'ç„¡';
                const violations = d.violations ? d.violations.join('<br>') : d.msg;
                content = `<div class="keyword-info"><div><strong>ç¦æ­¢é—œéµå­—:</strong> ${forbiddenList}</div><div><strong>å¿…é ˆé—œéµå­—:</strong> ${requiredList}</div><div style="margin-top:8px"><strong>é•è¦é …ç›®:</strong><br>${violations}</div></div>`;
            } else if (d.status === 'FAIL' && d.case === 'Compilation') {
                content = `<div class="compile-log"><strong>ç·¨è­¯éŒ¯èª¤æ—¥èªŒ:</strong><br><br>${d.log || 'ç„¡æ—¥èªŒ'}</div>`;
            } else if (d.status === 'FAIL') {
                content = `<div class="diff-block"><div class="diff-col"><h5>é æœŸè¼¸å‡º (Expected)</h5><div class="diff-box">${d.expected}</div></div><div class="diff-col"><h5>å¯¦éš›è¼¸å‡º (Got)</h5><div class="diff-box">${d.got}</div></div></div><div class="mt-1"><h5>è¼¸å…¥ (Input)</h5><div class="diff-box">${d.input}</div></div>`;
            } else if (d.status === 'TLE') {
                content = `<div>æ™‚é–“é™åˆ¶: ${d.timeout}s</div><div class="mt-1"><h5>è¼¸å…¥ (Input)</h5><div class="diff-box">${d.input}</div></div>`;
            } else if (d.status === 'ERROR') {
                content = `<div class="keyword-info"><strong>åŸ·è¡ŒéŒ¯èª¤:</strong> ${d.msg}</div>`;
            }
            return `<div class="result-item"><div class="result-summary ${statusClass}" onclick="this.nextElementSibling.classList.toggle('is-open')">æ¸¬è©¦ #${i+1}: ${d.status}</div><div class="result-details">${content}</div></div>`;
        }).join('');
    }

    function rerunCurrent() {
        if (currentProb) runProblem(null, currentProb);
    }

    function closeModal() {
        document.getElementById('modal-overlay').classList.remove('is-visible');
    }

    function openHelpModal() {
        document.getElementById('help-modal-overlay').classList.add('is-visible');
        // Load markdown content
        fetch('/static/help.md')
            .then(res => res.text())
            .then(md => {
                const html = renderMarkdown(md);
                document.getElementById('help-modal-body').innerHTML = `<div class="help-content">${html}</div>`;
            })
            .catch(err => {
                console.error(err);
                document.getElementById('help-modal-body').innerHTML = '<p>Failed to load help.</p>';
            });
    }

    function closeHelpModal() {
        document.getElementById('help-modal-overlay').classList.remove('is-visible');
    }

    // Editor variables
    let editor = null;
    let editorLoaded = false;
    let editorInitializing = false;

    function initEditor() {
        if (editorLoaded || editorInitializing) return;
        editorInitializing = true;
        
        const isDark = document.body.classList.contains('dark-theme');
        
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            editor = monaco.editor.create(document.getElementById('editor-container'), {
                value: '// Loading...',
                language: 'cpp',
                theme: isDark ? 'vs-dark' : 'vs',
                automaticLayout: true,
                minimap: { enabled: false }
            });
            
            // Enable save button on change
            editor.onDidChangeModelContent(() => {
                document.getElementById('btn-save').disabled = false;
                document.getElementById('btn-save').classList.remove('btn-secondary');
                document.getElementById('btn-save').classList.add('btn');
            });
            
            // Mark editor as loaded FIRST
            editorLoaded = true;
            editorInitializing = false;
            
            // Then load code
            if (currentProb) {
                console.log('Editor initialized, loading code for:', currentProb);
                loadCode(currentProb);
            }
        });
    }

    function switchTab(tab) {
        // Remove active from all tabs and contents
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
            content.style.display = 'none';  // æ˜ç¢ºéš±è—æ‰€æœ‰ tab
        });
        
        // Activate selected tab button
        document.querySelector(`.tab-btn[onclick*="'${tab}'"]`).classList.add('active');
        const tabContent = document.getElementById(`tab-${tab}`);
        tabContent.classList.add('active');
        
        // Handle specific tab content display
        if (tab === 'info') {
            tabContent.style.display = 'block';
        } else if (tab === 'code') {
            // Code tab needs flex layout for editor
            tabContent.style.display = 'flex';
            
            if (!editorLoaded && !editorInitializing) {
                console.log('Initializing editor...');
                initEditor();
            } else if (editorLoaded && editor) {
                console.log('Editor already loaded, updating layout');
                editor.layout();
                // Always reload code when switching to code tab
                if (currentProb) {
                    console.log('Reloading code for:', currentProb);
                    loadCode(currentProb);
                }
            }
        } else if (tab === 'results') {
            // Results tab needs block layout
            tabContent.style.display = 'block';
            console.log('Switched to results tab');
        }
    }

    async function loadCode(probName) {
        if (!editor) {
            console.error('Editor not ready yet');
            return;
        }
        try {
            console.log('Fetching code for:', probName);
            const res = await fetch(`/api/code/${probName}`);
            const data = await res.json();
            console.log('Code fetched, length:', data.content ? data.content.length : 0);
            if (data.content) {
                editor.setValue(data.content);
                // Reset save button
                document.getElementById('btn-save').disabled = true;
                document.getElementById('btn-save').classList.add('btn-secondary');
                document.getElementById('btn-save').classList.remove('btn');
                console.log('Code loaded successfully');
            }
        } catch (err) {
            console.error('Failed to load code:', err);
            editor.setValue('// Failed to load code');
        }
    }

    async function saveCode() {
        if (!editor || !currentProb) return;
        const content = editor.getValue();
        try {
            const res = await fetch(`/api/code/${currentProb}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: content })
            });
            const data = await res.json();
            if (data.success) {
                // Disable save button
                document.getElementById('btn-save').disabled = true;
                document.getElementById('btn-save').classList.add('btn-secondary');
                document.getElementById('btn-save').classList.remove('btn');
            } else {
                alert('å„²å­˜å¤±æ•—: ' + data.error);
            }
        } catch (err) {
            alert('å„²å­˜å¤±æ•—: ' + err);
        }
    }
    
    async function runFromEditor() {
        if (!document.getElementById('btn-save').disabled) {
            await saveCode();
        }
        switchTab('results');
        document.getElementById('results-container').innerHTML = `
            <div class="loading-container">
                <div class="spinner"></div>
                <p>åŸ·è¡Œæ¸¬è©¦ä¸­...</p>
            </div>`;
            
        try {
            // Add timeout to prevent indefinite loading
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const res = await fetch(`/api/run/${currentProb}`, { 
                method: 'POST',
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            
            const data = await res.json();
            
            // Update the problem data
            const p = problems.find(x => x.name === currentProb);
            if (p) {
                p.score = data.score;
                p.total_points = data.total_points;
                p.passed = data.passed_count;
                p.total_tests = data.total_count;
                p.has_run = true;
                p.details = data.details;
            }
            
            // Update stats
            const barEl = document.getElementById(`bar-${currentProb}`);
            if (barEl) {
                const pct = data.total_count > 0 ? (data.passed_count / data.total_count) * 100 : 0;
                barEl.style.width = `${pct}%`;
                barEl.className = data.passed_count === data.total_count && data.total_count > 0 ? 'progress-bar' : 'progress-bar fail';
                document.getElementById(`score-${currentProb}`).textContent = `å¾—åˆ†: ${data.score}/${data.total_points}`;
                document.getElementById(`tests-${currentProb}`).textContent = `æ¸¬è©¦: ${data.passed_count}/${data.total_count}`;
                const newStatus = (data.fail_count === 0 && data.total_count > 0) ? 'pass' : 'fail';
                const statusText = newStatus === 'pass' ? 'é€šé' : 'å¤±æ•—';
                const statusIndicator = document.getElementById(`status-${currentProb}`);
                statusIndicator.className = `status-indicator ${newStatus}`;
                statusIndicator.textContent = statusText;
                updateStats();
            }
            
            // Render results in Results tab (always, even if empty or error)
            if (data.details && data.details.length > 0) {
                document.getElementById('results-container').innerHTML = renderTestResults(data.details);
            } else {
                document.getElementById('results-container').innerHTML = '<div style="text-align:center; padding: 32px; color: var(--cds-text-secondary);">æ²’æœ‰æ¸¬è©¦çµæœ</div>';
            }
            
        } catch (err) {
            console.error(err);
            let errorMsg = 'åŸ·è¡Œå¤±æ•—';
            if (err.name === 'AbortError') {
                errorMsg = 'åŸ·è¡Œé€¾æ™‚ï¼ˆè¶…é30ç§’ï¼‰';
            } else if (err.message) {
                errorMsg = 'åŸ·è¡Œå¤±æ•—: ' + err.message;
            }
            document.getElementById('results-container').innerHTML = '<p style="color:var(--cds-danger); text-align:center; padding: 32px;">' + errorMsg + '</p>';
        }
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', init);
    
    // Handle resize
    window.addEventListener('resize', () => {
        if (editor) editor.layout();
    });
</script>
